{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Importing required libraries\n",
    " \n",
    "import numpy as np\n",
    "import random\n",
    "import csv\n",
    "import pandas as pd\n",
    "import math\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "class TransitionModel:\n",
    "    V_min=-5\n",
    "    V_max=5\n",
    "    points=4000 \n",
    "\n",
    "    States=['I','II','III','X']\n",
    "    \n",
    "    def __init__(self, state='I'):\n",
    "        self.state=state\n",
    "        if state== 'I':  \n",
    "            self.Voltage = np.linspace(0,TransitionModel.V_max, 2000)\n",
    "            self.meanI = 0\n",
    "            self.meanII = random.randrange(2500, 42500, 25)/10000 # mean to represent transition to state II\n",
    "            self.meanIII = random.randrange(math.ceil((self.meanI+0.25)*10000), 45000, 25)/10000\n",
    "            self.meanX_1 = random.randrange(math.ceil((self.meanII+0.25)*10000), 50000, 25)/10000\n",
    "        elif state== 'II':       \n",
    "            self.Voltage = np.linspace(TransitionModel.V_min,TransitionModel.V_max,TransitionModel.points)\n",
    "            self.meanI=-random.randrange(5000, 42500, 25)/10000 #to state I\n",
    "            self.meanII=0\n",
    "            self.meanIII=random.randrange(5000, 42500, 25)/10000\n",
    "            self.meanX_1 = random.randrange(math.ceil((self.meanIII+0.25)*10000), 50000, 25)/10000\n",
    "            self.meanX_2 = -random.randrange(math.ceil((abs(self.meanI)+0.25)*10000), 45000, 25)/10000 #for the negative polarity fail \n",
    "        elif state== 'III':   \n",
    "            self.Voltage = np.linspace(TransitionModel.V_min,0,TransitionModel.points/2)\n",
    "            self.meanIII=0\n",
    "            self.meanII = -random.randrange(2500, 42500, 25)/10000 # mean to represent transition to state II\n",
    "            self.meanI = -random.randrange(math.ceil((self.meanII+0.25)*10000), 45000, 25)/10000\n",
    "            self.meanX2 = -random.randrange(math.ceil((self.meanI+0.25)*10000), 50000, 25)/10000\n",
    "            \n",
    "            \n",
    "    def normal_dist(self, x , mean , sd=1):\n",
    "        prob_density = (1/(sd*(2*np.pi)**(0.5)))* np.exp(-0.5*((x-mean)/sd)**2)\n",
    "        return prob_density\n",
    "    \n",
    "    def generate_probablity(self):\n",
    "        self.prob_I=normal_dist(self.Voltage,self.meanI)\n",
    "        self.prob_II=normal_dist(self.Voltage,self.meanII)\n",
    "        self.prob_III=normal_dist(self.Voltage,self.self.meanIII)\n",
    "        self.prob_X1=normal_dist(self.Voltage,self.meanX_1)\n",
    "        self.prob_X2=normal_dist(self.Voltage,self.meanX_2)\n",
    "        \n",
    "        if state== 'I': \n",
    "            self.prob_I=normal_dist(self.Voltage,self.meanI)/normal_dist(0,0)\n",
    "            self.prob_X2=normal_dist(self.Voltage,self.meanX_2)/0\n",
    "        elif state== 'II': \n",
    "            self.prob_II=normal_dist(self.Voltage,self.meanII)/normal_dist(0,0)   \n",
    "        elif state== 'III':\n",
    "            self.prob_III=normal_dist(self.Voltage,self.self.meanIII)/normal_dist(0,0)\n",
    "            self.prob_X1=normal_dist(self.Voltage,self.meanX_1)/0\n",
    "            \n",
    "        Cumulative_prob=self.prob_I + self.prob_II + self.prob_III + self.prob_X1 +self.prob_X2\n",
    "        \n",
    "        self.prob_I= self.prob_I/ Cumulative_prob\n",
    "        self.prob_II= self.prob_II/ Cumulative_prob\n",
    "        self.prob_III= self.prob_III/ Cumulative_prob\n",
    "        self.prob_X1= self.prob_X1/ Cumulative_prob\n",
    "        self.prob_X2= self.prob_X2/ Cumulative_prob\n",
    "        combined_list=[self.prob_I, self.prob_II, self.prob_III, self.prob_X1, self.prob_X2]\n",
    "        return combined_list\n",
    "        \n",
    "    def plot_pdf(self):\n",
    "        \n",
    "        fig = plt.figure( )  \n",
    "        plt.plot(self.Voltage, self.prob_I , color = 'green')\n",
    "        plt.plot(self.Voltage, self.prob_II , color = 'blue')\n",
    "        plt.plot(self.Voltage, self.prob_III , color = 'black')\n",
    "        plt.plot(self.Voltage, self.prob_X1 , color = 'red')\n",
    "        plt.plot(self.Voltage, self.prob_X2 , color = 'red')\n",
    "        \n",
    "        plt.title('Trantition for state '+ str(self.state))\n",
    "        plt.legend([str(self.state)+\" to I\",str(self.state)+\" to II\", \n",
    "                    str(self.state)+\" to III\",str(self.state)+ \" to X\"])\n",
    "        plt.xlabel('Voltage')\n",
    "        plt.ylabel('Probability Density')\n",
    "\n",
    "        plt.show()\n",
    "\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
